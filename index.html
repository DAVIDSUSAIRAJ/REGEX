<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <h1>Regex</h1>

  <script>
    //SPECIAL CHARACTERS NOT ALLOWED REGEXD(ONLY ALBHANUMERIC EX(DAVID5 OR david96))
    //     let hasSpeciaCharacter = e.target.value.split("").includes("-");
    //    if (e.target.value.match(/[!@#^&*()?%{}+=<>;:.,_|`\\$'"/\s/\[\]]/) ||hasSpeciaCharacter) return false;


    // THIS IS FOR  MINUS VALUE ONLY ALLOWED. AND TWO DIGITS ONLY ALLOWED AFTER DOT (EX: -0.55)
    // const regex = /^-?(\s*|\d+(\s*|(\.\d{0,2})))?$/
    //                       if(regex.test(e.target.value)){
    //                         setMinTemp(e.target.value)}
    //  


    // THIS IS FOR NUMBERS ONLY ALLOWED(DECIMAL) EX:(0O.87)
    // const regex = /^(\s*|\d+(\s*|(\.\d{0,2})))?$/
    //                       if(regex.test(e.target.value)){
    //                         setForward(e.target.value)}
    //                       } 

    // NOTE: VALUE.match(regex) or regex.test(value)
    //NOTE: VALUE IS RETURN THE VALUE;
    //NOTE: TEST IS RETURN THE BOOLEANM[]

    // let hasSpeciaCharacter = e.target.value.split("").includes("-");
    //                     if (e.target.value.match(/[!@#^&*()?%{}+=<>;:.,_|`\\$'"/\s/\[\]]/) ||hasSpeciaCharacter) return false;
    //                     setOperatorCode(e.target.value)}
    //                   } 

    // useImperativeHandle(ref, () => {
    //         return {
    //             getValue: () => {
    //                 let dateString = null;
    //                 if (selectedDate) {
    //                     dateString = format(selectedDate, 'dd/MM/yyyy');
    //                 }
    //                 return dateString;
    //             },
    //             isCancelAfterEnd: () => {
    //                 return !selectedDate;
    //             },
    //             afterGuiAttached: () => {
    //                 if (!props.value) {
    //                     return;
    //                 }
    //                 const [_, day, month, year] = props.value.match(/(\d{2})\/(\d{2})\/(\d{4})/);
    //                 let selectedDate = new Date(year, month - 1, day);
    //                 setSelectedDate(selectedDate);
    //             }
    //         };
    //     });


    //THIS IS FOR ONLY GET NUMBERS(EX:"DAVID 5.55") ANS: 5.55
    // let x = "DAVID 5.55";
    // let regex = x.match(/[0-9\.]/g);
    // console.log(regex,"regex")

    //     //START//THIS IS FOR IMPORT EXCEL

    //     import * as XLSX from "xlsx";


    // <input type="file" className="upload"  onChange={(e) => { importRecord(e)}} /> // should be input type file

    // const importRecord=(e)=>{
    // 		let file = File;
    // 		let files = e.target.files;
    // 		var extension = files[0].name.substring(files[0].name.lastIndexOf("."), files[0].name.length);
    // 		if (extension.toLowerCase() === ".xls" || extension.toLowerCase() === ".xlsx" || extension.toLowerCase() === ".csv") {
    // 		  file = e.target.files[0];
    // 		  if (typeof (document.getElementById("filename")) != 'undefined' && document.getElementById("filename") != null) {
    // 			document.getElementById("filename").value = file.name;
    // 		  }
    // 		  let readFile = new FileReader();
    // 		  readFile.readAsArrayBuffer(file); // It  is used to start reading the contents of a specified  File
    // 		  readFile.onload = () => {
    // 			let storeData = readFile.result;
    //             var data =fileUpload(storeData,"cargolist" );

    // 		}
    // 		}
    //     }
    // 	function fileUpload(storeData,sheetName) {

    // 		try {
    // 		  let workbook;
    // 		  /* start------->convert data to binary string  */
    // 		  let data = new Uint8Array(storeData);  
    // 		  let arr = [];
    // 		  for (let i = 0; i !== data.length; ++i) {
    // 			arr[i] = String.fromCharCode(data[i]);
    // 		  }
    // 		  let bstr = arr.join('');
    // 		  workbook = XLSX.read(bstr, {            //note: confusing place--> XlSX instead of importing file has XLS format. it must be XLSX format
    // 			type: 'binary'
    // 		  });
    // 		  /* end------->convert data to binary string  */
    // 		  let wbook = workbook;
    // 		  let first_sheet_name = wbook.SheetNames[0]; //first_sheet_name--> file name of importing file

    // 		  if (sheetName !== first_sheet_name) {
    // 			let worksheet = wbook.Sheets[first_sheet_name];

    // 			var ExcelHeaders = XLSX.utils.sheet_to_json(worksheet, {
    // 			  header: 0
    // 			});
    // 			return ExcelHeaders; //ExcelHeaders --> it give array of object
    // 		}
    // 	  } catch (e) {
    // 		  if (e instanceof Error) {
    // 			console.log("The exception in fileUpload Method" + e.message);
    // 			console.log(e.stack);
    // 		  }

    // 		  return false;
    // 		}

    // 	}


    //END

    //START//HEX TO RGB VALUE
    //   hexToRgb = str => {
    // 	if (/^#([0-9a-f]{3}|[0-9a-f]{6})$/gi.test(str)) {
    // 		var hex = str.substr(1);
    // 		hex = hex.length == 3 ? hex.replace(/(.)/g, '$1$1') : hex;
    // 		var rgb = parseInt(hex, 16);
    // 		return [(rgb >> 16) & 255, (rgb >> 8) & 255, rgb & 255].join(',');
    // 	}
    // 	return false;
    // };



    //END HEX TO RGB VALUE

    //START// RGB TO HEX
    //   RgbToHex = str => {
    // 	let col1;
    // 	let col2;
    // 	let col3;
    // 	let col;
    // 	col1 =
    // 		parseInt(str.split(',')[0]).toString(16).length === 1
    // 			? '0' + parseInt(str.split(',')[0]).toString(16)
    // 			: parseInt(str.split(',')[0]).toString(16);
    // 	col2 =
    // 		parseInt(str.split(',')[1]).toString(16).length === 1
    // 			? '0' + parseInt(str.split(',')[1]).toString(16)
    // 			: parseInt(str.split(',')[1]).toString(16);
    // 	col3 =
    // 		parseInt(str.split(',')[2]).toString(16).length === 1
    // 			? '0' + parseInt(str.split(',')[2]).toString(16)
    // 			: parseInt(str.split(',')[2]).toString(16);
    // 	col = '#' + col1 + col2 + col3;
    // 	return col;
    // };

    //END//RGB TO HEX

    //START//INBOUND AND OUTBOUND REDUX PERSIST
    // import _ from '@lodash';
    // import { createTransform } from 'redux-persist';

    //  const NEW_SONATA_MAP_TYPE = 'MAP'
    //  const NEW_SONATA_ARRAY_TYPE = 'ARRAY'
    //  const NEW_SONATA_SET_TYPE = 'SET'
    //  const NEW_SONATA_PERSIST_TYPE = 'NeWsOnAtApErSiStTyPe'

    // const transform = createTransform(
    //   // transform state on its way to being serialized and persisted.
    //   (inboundState, key) => {
    //     // convert mySet to an Array.
    //      return transformToArray(inboundState)
    //   },
    //   // transform state being rehydrated
    //   (outboundState, key) => {
    //     // convert mySet back to a Set.
    //     return  transformFromArray(outboundState)
    //   },
    //   // define which reducers this transform gets called for.
    //   { whitelist: ['TankCondition'] }
    // );


    // export const transformToArray = (dataToTransform) => {
    //   if(dataToTransform instanceof Map){
    //     const transformedData = new Map()
    //     dataToTransform.forEach((k, v) => {
    //       if(k instanceof Map || k instanceof Array || k instanceof Set || k instanceof Object){
    //         transformedData.set(v, transformToArray(k))
    //       }else {
    //         transformedData.set(v, k);
    //       }
    //     })
    //     transformedData.set(NEW_SONATA_PERSIST_TYPE, NEW_SONATA_MAP_TYPE)
    //     return Array.from(transformedData)
    //   }else if(dataToTransform instanceof Array){
    //     const transformedData = []
    //     dataToTransform.forEach((value) => {
    //       if(value instanceof Map || value instanceof Array || value instanceof Set || value instanceof Object){
    //         transformedData.push(transformToArray(value))
    //       }else{
    //         transformedData.push(value)
    //       }
    //     })
    //     transformedData.push([NEW_SONATA_PERSIST_TYPE, NEW_SONATA_ARRAY_TYPE])
    //     return transformedData
    //   }else if(dataToTransform instanceof Set){
    //     const transformedData = new Set()
    //     dataToTransform.forEach((value) => {
    //       if(value instanceof Map || value instanceof Array || value instanceof Set || value instanceof Object){
    //         transformedData.add(transformToArray(value))
    //       }else{
    //         transformedData.add(value)
    //       }
    //     })
    //     transformedData.add([NEW_SONATA_PERSIST_TYPE, NEW_SONATA_SET_TYPE])
    //     return Array.from(transformedData)
    //   }else if(dataToTransform instanceof Object){
    //     const transformedData = {}
    //     for(const[v, k] of Object.entries(dataToTransform)) {
    //       if(k instanceof Map || k instanceof Array || k instanceof Set || k instanceof Object){
    //         transformedData[v] = transformToArray(k)
    //       }else {
    //         transformedData[v] = k;
    //       }
    //     }
    //     return transformedData
    //   }
    // }

    // export const transformFromArray = (arrayData, key = 'ss') => {
    //   const typeData = arrayData instanceof Array ? arrayData[arrayData.length - 1] : []
    //   const type = typeData && typeData.length > 0 && typeData[0] === NEW_SONATA_PERSIST_TYPE ? typeData[1] : ''
    //   if(arrayData instanceof Array){
    //     arrayData.pop()
    //   }
    //   if(type === NEW_SONATA_MAP_TYPE){
    //     const transformedData = new Map()
    //     arrayData.forEach((v) => {
    //       if(v[1] instanceof Array || v[1] instanceof Object){
    //         transformedData.set(v[0], transformFromArray(v[1]))
    //       }else {
    //         transformedData.set(v[0], v[1]);
    //       }
    //     })
    //     return transformedData
    //   }else if(type === NEW_SONATA_ARRAY_TYPE){
    //     const transformedData = []
    //     arrayData.forEach((value) => {
    //       if(value instanceof Array || value instanceof Object){
    //         transformedData.push(transformToArray(value))
    //       }else{
    //         transformedData.push(value)
    //       }
    //     })
    //     return transformedData
    //   }else if(type === NEW_SONATA_SET_TYPE){
    //     const transformedData = new Set()
    //     arrayData.forEach((value) => {
    //       if(value instanceof Array || value instanceof Object){
    //         transformedData.add(transformToArray(value))
    //       }else{
    //         transformedData.add(value)
    //       }
    //     })
    //     return transformedData
    //   }else if(arrayData instanceof Object){
    //     const transformedData = {}
    //     for(const [v, k] of Object.entries(arrayData)){
    //       if(k instanceof Array || k instanceof Object){
    //         transformedData[v] = transformFromArray(k)
    //       }else{
    //         transformedData[v] = k
    //       }
    //     }
    //     return transformedData
    //   }
    //   return arrayData
    // }


    // export default transform

    //END // INBOUND AND OUTBOUND REDUX PERSIST


    // THIS IS NEW WITH SPRAD OPERATOR 
    // const planPatternTransform = createTransform(
    //   // transform state on its way to being serialized and persisted.
    //   (inboundState, key) => {
    //     // convert mySet to an Array.
    //     // console.log("inboundState", inboundState)

    //     const obj = {...inboundState,
    //         Hot_Works_Ban_Stacks: transformToArray(inboundState.Hot_Works_Ban_Stacks),
    //         DG_Pref_Stacks: transformToArray(inboundState.DG_Pref_Stacks),
    //         Rfr_Pref_Stacks: transformToArray(inboundState.Rfr_Pref_Stacks),
    //         Rfr_Ban_Stacks: transformToArray(inboundState.Rfr_Ban_Stacks), 
    //         Empty_Pref_Stacks: transformToArray(inboundState.Empty_Pref_Stacks), 
    //         Hm20_Strict_Stacks: transformToArray(inboundState.Hm20_Strict_Stacks), 
    //         Hm40_Strict_Stacks: transformToArray(inboundState.Hm40_Strict_Stacks), 
    //         _Pod_Preference: transformToArray(inboundState._Pod_Preference), 
    //         _Pod_Slot_Preference: transformToArray(inboundState._Pod_Slot_Preference), 
    //         _IMO1_Stacks: transformToArray(inboundState._IMO1_Stacks), 
    //         _Pol_Preference: transformToArray(inboundState._Pol_Preference), 
    //         Slot_Ban_Slots: transformToArray(inboundState.Slot_Ban_Slots), 
    //         DG_Ban_Slots: transformToArray(inboundState.DG_Ban_Slots),
    //         remarks: transformToArray(inboundState.remarks)
    //     }
    //     return obj
    //   },
    //   // transform state being rehydrated
    //   (outboundState, key) => {
    //     // convert mySet back to a Set.
    //     // console.log("outbound state", outboundState)
    //     const obj =  {...outboundState,
    //         Hot_Works_Ban_Stacks: transformFromArray(outboundState.Hot_Works_Ban_Stacks),
    //         DG_Pref_Stacks: transformFromArray(outboundState.DG_Pref_Stacks),
    //         Rfr_Pref_Stacks: transformFromArray(outboundState.Rfr_Pref_Stacks),
    //         Rfr_Ban_Stacks: transformFromArray(outboundState.Rfr_Ban_Stacks), 
    //         Empty_Pref_Stacks: transformFromArray(outboundState.Empty_Pref_Stacks), 
    //         Hm20_Strict_Stacks: transformFromArray(outboundState.Hm20_Strict_Stacks), 
    //         Hm40_Strict_Stacks: transformFromArray(outboundState.Hm40_Strict_Stacks), 
    //         _Pod_Preference: transformFromArray(outboundState._Pod_Preference), 
    //         _Pod_Slot_Preference: transformFromArray(outboundState._Pod_Slot_Preference), 
    //         _IMO1_Stacks: transformFromArray(outboundState._IMO1_Stacks), 
    //         _Pol_Preference: transformFromArray(outboundState._Pol_Preference), 
    //         Slot_Ban_Slots: transformFromArray(outboundState.Slot_Ban_Slots), 
    //         DG_Ban_Slots: transformFromArray(outboundState.DG_Ban_Slots),
    //         remarks: transformFromArray(outboundState.remarks, 'remarks')
    //     }
    //     return obj
    //   },
    //   // define which reducers this transform gets called for.
    //   { whitelist: ['planPattern'] }
    );

    // END NEW WIEH SPREAD OPERATOR
  </script>

</body>

</html>